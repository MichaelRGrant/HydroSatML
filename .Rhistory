gradient <- -(2/n) * sum(x[i,j]*(y[i]-sum(beta[j]*x[i,j]))) + sum(2*lambda*beta[j])
}
}
return(gradient)
}
computegrad(training, y.train, matrix(c(rep(0,ncol(x))), nrow=1), 0.1)
graddescent <- function(computegrad, beta_init = matrix(c(rep(0,ncol(x))), nrow=1), t, max_iter = 1000){
iter <- 1
beta <-beta_init
beta_vals <- c()
beta_vals[iter] <- beta
grad <- computegrad(x,y,beta,lambda=0.1)
while(iter < max_iter){
beta = beta - t*computegrad(training,y.train,beta[iter],lambda=0.1)
beta_vals <- rbind(beta_vals, beta)
iter = iter + 1
}
return(beta_vals)
}
graddescent(computegrad, t=0.1)
graddescent <- function(computegrad, beta_init = matrix(c(rep(0,ncol(x))), nrow=1), t, max_iter = 1000){
iter <- 1
beta <-beta_init
beta_vals <- c()
beta_vals[iter] <- beta
grad <- computegrad(x,y,beta,lambda=0.1)
while(iter < max_iter){
beta = beta - t*computegrad(training,y.train,beta[iter],lambda=0.1)
beta_vals[iter] <-  beta
iter = iter + 1
}
return(beta)
}
graddescent(computegrad, t=0.1)
warnings()
graddescent <- function(computegrad, beta_init = matrix(c(rep(0,ncol(x))), nrow=1), t, max_iter = 1000){
iter <- 1
beta <-beta_init
# beta_vals <- c()
beta_vals <- beta
grad <- computegrad(x,y,beta,lambda=0.1)
while(iter < max_iter){
beta = beta - t*computegrad(training,y.train,beta[iter],lambda=0.1)
beta_vals <-  rbind(beta_vals, beta)
iter = iter + 1
}
return(beta)
}
graddescent(computegrad, t=0.1)
graddescent <- function(computegrad, beta_init = matrix(c(rep(0,ncol(x))), nrow=1), t, max_iter = 1000){
iter <- 1
beta <-beta_init
# beta_vals <- c()
beta_vals <- beta
grad <- computegrad(x,y,beta,lambda=0.1)
while(iter < max_iter){
beta = beta - t*computegrad(training,y.train,beta,lambda=0.1)
beta_vals <-  rbind(beta_vals, beta)
iter = iter + 1
}
return(beta)
}
graddescent(computegrad, t=0.1)
source('~/MS_Data_Science/DATA_558/Homework/HW2/mrgrant_hw2.R', echo=TRUE)
beta <- graddescent(computegrad, training, y.train,beta_init= numeric=ncol(training),t=0.1)
beta <- graddescent(computegrad, training, y.train,beta_init= numeric(ncol(training)),t=0.1)
source('~/MS_Data_Science/DATA_558/Homework/HW2/mrgrant_hw2.R', echo=TRUE)
graddescent <- function(computegrad, x, y, beta_init, t, max_iter = 1000){
iter <- 1
beta <- beta_init
beta_vals <- beta
while(iter < max_iter){
beta = beta - t*computegrad(x,y,beta,lambda=0.1)
beta_vals <-  rbind(beta_vals, beta)
iter = iter + 1
}
return(beta_vals)
}
beta <- graddescent(computegrad, training, y.train,beta_init= numeric(ncol(training)),t=0.1)
beta
beta[1000]
beta[1000,]
f_ridge_fast_c(beta,lambda = 0.1)
f_ridge_fast_c(beta[1000,],lambda = 0.1)
objective_fun <- function(beta, x=training, y=y.train, lambda){
p = length(beta)
n = nrow(x)
obj = sum((y-x%*%beta)^2)/n + lambda*sum(beta^2)
return(obj)
}
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)))
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)), pch=19)
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)), pch=21)
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)), pch=17)
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)), pch=18)
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)), pch=20)
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)), pch=20, cex = 0.5)
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)), pch=20, cex = 0.2)
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)), pch=20, cex = 0.3)
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)),
pch=20, cex = 0.3, ylab = 'F(beta)', xlab = 'Iteration', main = 'Gradient Descent into the Seven Circles')
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)),
pch=20, cex = 0.3, ylab = 'F(beta)', xlab = 'Iteration', main = 'Gradient Descent into the Abyss')
Bt <- beta[1000,]
B* <- 'test'
?glmnet
ridgeMod <- glmnet(training, y.train, alpha = 0, lambda = 0.1, intercept = F)
ridgeMod$beta
B.star <- ridgeMod$beta
apply(c(Bt,B.star), 1, function(x) objective_fun(x, lambda = 0.1))
apply(c(Bt,B.star), 2, function(x) objective_fun(x, lambda = 0.1))
apply(as.matrix(c(Bt,B.star), ncol = 2), 2, function(x) objective_fun(x, lambda = 0.1))
apply(as.matrix(c(Bt,B.star), ncol = 2), 1, function(x) objective_fun(x, lambda = 0.1))
objective_fun(Bt, lambda =0.1)
objective_fun(B.star, lambda=0.1)
steps <- 1/10^seq(0,1,0.001)
steps
steps <- 1/10^seq(0,1,0.01)
steps <- 1/10^seq(0,2,0.05)
steps
steps <- log(seq(1,20,1))
steps
steps <- 1/10^seq(1,10,1)
steps
steps <- 1/10^seq(1,5,1)
steps
steps <- 1/10^seq(1,5,1)
betas <- data.frame()
for(i in 1:length(steps)){
beta <- graddescent(computegrad, training, y.train, beta_init = numeric(ncol(trainin)), steps[i])
betas <- beta
betas <- cbind(betas, beta)
}
steps <- 1/10^seq(1,5,1)
betas <- data.frame()
for(i in 1:length(steps)){
beta <- graddescent(computegrad, training, y.train, beta_init = numeric(ncol(training)), steps[i])
betas <- beta
betas <- cbind(betas, beta)
}
betas
dim(betas)
betas <- data.frame()
steps <- 1/10^seq(1,5,1)
beta <- graddescent(computegrad, training, y.train, beta_init = numeric(ncol(training)), steps[1])
dim(beta)
steps <- 1/10^seq(1,5,1)
betas <- data.frame()
for(i in 1:length(steps)){
beta <- graddescent(computegrad, training, y.train, beta_init = numeric(ncol(training)), steps[i])
final.beta <- beta[1000,]
betadf <- cbind(betadf, final.beta)
}
betadf <- data.frame()
for(i in 1:length(steps)){
beta <- graddescent(computegrad, training, y.train, beta_init = numeric(ncol(training)), steps[i])
final.beta <- beta[1000,]
betadf <- cbind(betadf, final.beta)
}
betadf <- data.frame()
for(i in 1:length(steps)){
beta <- graddescent(computegrad, training, y.train, beta_init = numeric(ncol(training)), steps[i])
final.beta <- beta[nrow(beta),]
betadf <- rbind(betadf, final.beta)
}
dim(betadf)
betadf
View(betadf)
length(steps)
names(betadf) <- colanmes(training)
names(betadf) <- colnames(training)
betadf
apply(betadf, 1, function(x) objective_fun(x, lambda=0.1))
which.min(apply(betadf, 1, function(x) objective_fun(x, lambda=0.1)))
all.obj <- apply(betadf, 1, function(x) objective_fun(x, lambda=0.1))
all.obj[which.min(all.obj)]
Bt <- graddescent(computegrad, training, y.train, beta_init = numeric(ncol(training)), t=0.1)[1000,]
ssx <- sum(X^2)
ssy <- sum(Y^2)
#generate 100 random X's and Y's that have a correlation of 0.8 with equal variance
set.seed(10)
X <- rnorm(100)
Y <- rnorm(100)
lm(Y~X -1)
lm(X~Y -1)
ssx <- sum(X^2)
ssy <- sum(Y^2)
#generate 100 random X's and Y's that have a correlation of 0.8 with equal variance
set.seed(10)
X <- rnorm(100)
Y <- rnorm(100)
lm(Y~X -1)
lm(X~Y -1)
ssx <- sum(X^2)
ssy <- sum(Y^2)
#generate 100 random X's and Y's that have a correlation of 0.8 with equal variance
set.seed(10)
X <- rnorm(1000)
Y <- rnorm(1000)
lm(Y~X -1)
lm(X~Y -1)
ssx <- sum(X^2)
ssy <- sum(Y^2)
#generate 100 random X's and Y's that have a correlation of 0.8 with equal variance
set.seed(10)
X <- rnorm(10000)
Y <- rnorm(10000)
lm(Y~X -1)
lm(X~Y -1)
ssx <- sum(X^2)
ssy <- sum(Y^2)
#generate 100 random X's and Y's that have a correlation of 0.8 with equal variance
set.seed(10)
X <- rnorm(100000)
Y <- rnorm(100000)
lm(Y~X -1)
lm(X~Y -1)
ssx <- sum(X^2)
ssy <- sum(Y^2)
#generate 100 random X's and Y's that have a correlation of 0.8 with equal variance
set.seed(10)
X <- rnorm(100)
Y <- rnorm(100)
lm(Y~X -1)
lm(X~Y -1)
ssx <- sum(X^2)
ssy <- sum(Y^2)
#generate 100 random X's and Y's that have a correlation of 0.8 with equal variance
set.seed(10)
X <- rnorm(100)
Y <- -X
lm(Y~X -1)
lm(X~Y -1)
ssx <- sum(X^2)
ssy <- sum(Y^2)
objective_fun <- function(beta, x=training, y=y.train, lambda){
p = length(beta)
n = nrow(x)
obj = sum((y-x%*%beta)^2)/n + lambda*sum(beta^2)
return(obj)
}
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)),
pch=20, cex = 0.3, ylab = 'F(beta)', xlab = 'Iteration',
main = 'Gradient Descent into the Abyss')
objective_fun <- function(beta, x=training, y=y.train, lambda){
p = length(beta)
n = nrow(x)
obj = sum((y-x%*%beta)^2)/n + lambda*sum(beta^2)
return(obj)
}
beta <- graddescent(computegrad, training, y.train, beta_init = numeric(ncol(training)), t=0.1)
plot(apply(beta, 1, function(x) objective_fun(x,lambda = 0.1)),
pch=20, cex = 0.3, ylab = 'F(beta)', xlab = 'Iteration',
main = 'Gradient Descent into the Abyss')
?sample
tmp <- seq(1,10000)
sample(tmp, 500, replace = F)
tmp <- seq(1,10000)
idx <- sample(tmp, 2000, replace = F)
tmp1 <- [-idx]
tmp1 <- tmp[-idx]
tmp1 <- tmp[idx]
tmp <- tmp[-idx]
idx <- sample(tmp, 2000, replace = F)
??CreateFolds
install.packages('DrugClust')
library(DrugClust)
CreateFolds(tmp, num_folds = 5)
nrow(tmp)
tmp
class(tmp)
tmp <- data.frame(tmp)
CreateFolds(tmp, num_folds = 5)
tmp1 <- CreateFolds(tmp, num_folds = 5)
CreateFolds(as.matrix(tmp), num_folds = 5)
CreateFolds(as.matrix(tmp), num_folds = 5)
sum(tmp1==0)
sum(tmp1==1)
sum(tmp1==2)
sum(tmp1==3)
sum(tmp1==)
sum(tmp1==4)
sum(tmp1==5)
1600*5
library(caret)
createFolds(tmp, k = 5)
class(tmp)
createFolds(tmp, k = 5, list = F)
tmp
shiny::runApp('Data_Science_Special/Dalphy_data/Shiny')
runApp('Data_Science_Special/Dalphy_data/Shiny')
library(rgdal)
library(ggplot2)
library(stringr)
setwd("/Volumes/Toshiba External USB HDD Media")
setwd("/Volumes/Toshiba External USB HDD Media")
setwd("/Volumes/Toshiba External USB HDD Media")
ndrefiles <- list.files(recursive = T, pattern = '*\\.asc$', full.names = T)
ndrefiles <- normalizePath(ndrefiles)
setwd("~/MS_Data_Science/Capstone/HydroSatML")
shpfiles <- list.files(path = './data/TierII_wshed_boundaries/',
recursive = T, pattern = '*\\.shp$', full.names = T)
shpfiles <- normalizePath(shpfiles)
for(i in 1:length(ndrefiles)){
print(i)
name <- str_extract(ndrefiles[i], '[^\\/]+$')
filename <- str_extract(ndrefiles[i], '[^\\/][^\\/]*$')
location <- str_extract(filename, '^[^_]*')
if(location == 'Aes'){
shpfile <- str_extract(shpfiles[1], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[1], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'J'){
shpfile <- str_extract(shpfiles[2], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[2], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'Od'){
shpfile <- str_extract(shpfiles[3], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[3], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'W'){
shpfile <- str_extract(shpfiles[4], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[4], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
tryCatch({
r <- raster(x = ndrefiles[i])
masked <- mask(r, shape)
}, error = function(e) {
print(e)
print(paste0('Error on number: ', i))
})
tryCatch({
trimmed <- trim(masked)
plot(trimmed)
path <- "/Users/mgrant/MS_Data_Science/Capstone/data/trimmed_ndre/"
finalname <- paste0(path, name)
print(finalname)
writeRaster(trimmed, filename = finalname, format = 'ascii', overwrite=T)
}, error = function(e) {
print(e)
print(paste0('Number ', i, ' error.'))
# error_log[e.num] <- 'testing'
# e.num = e.num + 1
} )
}
for(i in 1:length(ndrefiles)){
print(i)
name <- str_extract(ndrefiles[i], '[^\\/]+$')
filename <- str_extract(ndrefiles[i], '[^\\/][^\\/]*$')
location <- str_extract(filename, '^[^_]*')
if(location == 'Aes'){
shpfile <- str_extract(shpfiles[1], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[1], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'J'){
shpfile <- str_extract(shpfiles[2], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[2], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'Od'){
shpfile <- str_extract(shpfiles[3], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[3], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'W'){
shpfile <- str_extract(shpfiles[4], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[4], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
tryCatch({
r <- raster(x = ndrefiles[i])
masked <- mask(r, shape)
}, error = function(e) {
print(e)
print(paste0('Error on number: ', i))
})
tryCatch({
trimmed <- trim(masked)
plot(trimmed)
path <- "/Users/mgrant/MS_Data_Science/Capstone/data/trimmed_ndre/"
finalname <- paste0(path, name)
print(finalname)
writeRaster(trimmed, filename = finalname, format = 'ascii', overwrite=T)
}, error = function(e) {
print(e)
print(paste0('Number ', i, ' error.'))
# error_log[e.num] <- 'testing'
# e.num = e.num + 1
} )
}
library(rgdal)
for(i in 1:length(ndrefiles)){
print(i)
name <- str_extract(ndrefiles[i], '[^\\/]+$')
filename <- str_extract(ndrefiles[i], '[^\\/][^\\/]*$')
location <- str_extract(filename, '^[^_]*')
if(location == 'Aes'){
shpfile <- str_extract(shpfiles[1], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[1], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'J'){
shpfile <- str_extract(shpfiles[2], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[2], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'Od'){
shpfile <- str_extract(shpfiles[3], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[3], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'W'){
shpfile <- str_extract(shpfiles[4], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[4], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
tryCatch({
r <- raster(x = ndrefiles[i])
masked <- mask(r, shape)
}, error = function(e) {
print(e)
print(paste0('Error on number: ', i))
})
tryCatch({
trimmed <- trim(masked)
plot(trimmed)
path <- "/Users/mgrant/MS_Data_Science/Capstone/data/trimmed_ndre/"
finalname <- paste0(path, name)
print(finalname)
writeRaster(trimmed, filename = finalname, format = 'ascii', overwrite=T)
}, error = function(e) {
print(e)
print(paste0('Number ', i, ' error.'))
# error_log[e.num] <- 'testing'
# e.num = e.num + 1
} )
}
library(raster)
for(i in 1:length(ndrefiles)){
print(i)
name <- str_extract(ndrefiles[i], '[^\\/]+$')
filename <- str_extract(ndrefiles[i], '[^\\/][^\\/]*$')
location <- str_extract(filename, '^[^_]*')
if(location == 'Aes'){
shpfile <- str_extract(shpfiles[1], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[1], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'J'){
shpfile <- str_extract(shpfiles[2], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[2], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'Od'){
shpfile <- str_extract(shpfiles[3], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[3], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
else if(location == 'W'){
shpfile <- str_extract(shpfiles[4], '[^\\/][^\\/]*$')
shpfile <- str_extract(shpfile, '.*(?=\\.)')
shpfile_path <- str_extract(shpfiles[4], '^(.*[\\/])')
shape <- readOGR(shpfile_path, shpfile)
}
tryCatch({
r <- raster(x = ndrefiles[i])
masked <- mask(r, shape)
}, error = function(e) {
print(e)
print(paste0('Error on number: ', i))
})
tryCatch({
trimmed <- trim(masked)
plot(trimmed)
path <- "/Users/mgrant/MS_Data_Science/Capstone/data/trimmed_ndre/"
finalname <- paste0(path, name)
print(finalname)
writeRaster(trimmed, filename = finalname, format = 'ascii', overwrite=T)
}, error = function(e) {
print(e)
print(paste0('Number ', i, ' error.'))
# error_log[e.num] <- 'testing'
# e.num = e.num + 1
} )
}
length(list.files(path = '../data/trimmed_ndre/'))
132*12
60/1e6
*15
60/1e6
6e-5
6e-5*15
